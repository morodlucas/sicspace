<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoundLoop</title>
      <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e);
            color: white;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            overflow-y: auto;
            overflow-x: hidden; /* Previne scroll horizontal */
        }

        .visualizer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Atrás do conteúdo principal */
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            transition: transform 1.2s cubic-bezier(0.1, 1, 0.7, 1), opacity 1.2s linear;
        }

        .main-content {
            flex: 1;
            padding-right: 20px;
            transition: padding-right 0.3s ease;
        }

        .main-content.editor-visible {
            padding-right: 440px; /* Espaço para o painel do editor */
        }

        .container {
            text-align: center;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        .title-custom {
            font-size: 2.8rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .header-logo {
              max-width: 600px; /* Tamanho máximo da logo */
              width: 50%;     /* Responsividade básica */
              height: auto;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 2rem;
            font-style: italic;
        }

        .song-info {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 2rem;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .main-controls {
            margin-bottom: 2rem;
        }

        .main-controls .btn {
            font-size: 1rem;
            padding: 10px 20px;
            min-width: 120px;
        }

        .instruments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            max-width: 100%;
            margin: 0 auto 2rem;
        }

        .instrument-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .instrument-container.editing {
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.2);
        }
        
        .instrument-button-wrapper {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-family: inherit;
            font-size: 0.95rem;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            width: 100%;
        }
        
        .instrument-btn {
            flex-grow: 1;
        }
        
        .edit-btn {
            flex-shrink: 0;
            width: 50px;
            padding-left: 0;
            padding-right: 0;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }
        
        #playPauseBtn.active {
            background: rgba(190, 140, 255, 0.4);
            border-color: rgba(190, 140, 255, 0.7);
            box-shadow: 0 0 15px rgba(190, 140, 255, 0.5);
        }

        .btn.recording {
            background: rgba(255, 60, 60, 0.4);
            border-color: rgba(255, 60, 60, 0.7);
            box-shadow: 0 0 15px rgba(255, 60, 60, 0.5);
        }
        
        .btn.instrument-btn.active {
            background: rgba(100, 200, 255, 0.25);
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.3);
        }

        .midi-editor-panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: #101020;
            padding: 20px;
            box-shadow: -10px 0 25px rgba(0, 0, 0, 0.5);
            transition: right 0.3s ease;
            z-index: 100;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .midi-editor-panel.visible {
            right: 0;
        }
        
        .midi-editor-panel h3 {
            margin-top: 10px;
            color: #a5d8ff;
            flex-shrink: 0;
        }
        
        #closeEditorBtn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        #closeEditorBtn:hover {
            opacity: 1;
        }

        .midi-controls {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-shrink: 0;
        }

        .midi-controls label { font-size: 0.9rem; opacity: 0.8; text-align: right; }
        .midi-controls input, .midi-controls select {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; padding: 5px 8px; border-radius: 4px; font-family: inherit; font-size: 0.85rem; width: 100%;
        }

        .piano-roll-container {
            display: flex;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow-x: auto;
            overflow-y: auto;
            height: calc(100vh - 300px);
            flex-grow: 1;
            position: relative;
        }

        .piano-keys {
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 2;
            background: #101020;
        }
        
        .note-label {
            width: 60px;
            height: 20px; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.7rem;
            flex-shrink: 0;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .white-key { background: #fff; color: #000; }
        .black-key { background: #333; color: #fff; border-bottom: 1px solid #555; }
        .drum-key { background: rgba(255, 255, 255, 0.05); height: 40px; }

        .note-grid-wrapper {
            position: relative;
        }
        
        .note-grid {
            display: flex;
            flex-direction: row;
            position: relative;
        }

        .beat-column {
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .beat-column.beat-marker {
            border-left: 2px solid rgba(255, 255, 255, 0.3);
        }

        .note-cell {
            width: 35px;
            height: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: background-color 0.1s ease;
            box-sizing: border-box;
        }
        .drum-column .note-cell {
            height: 40px;
        }
        
        .note-cell:hover { background: rgba(255, 255, 255, 0.1); }
        .note-cell.active { background: rgba(100, 200, 255, 0.6); box-shadow: inset 0 0 10px rgba(100, 200, 255, 0.3); }

        .playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: #ff4444;
            z-index: 10;
            transition: left 0.05s linear;
            box-shadow: 0 0 10px #ff4444;
            pointer-events: none;
        }

        .pattern-controls {
            display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap; flex-shrink: 0;
        }
        .pattern-btn {
            padding: 6px 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; cursor: pointer; border-radius: 4px; font-size: 0.8rem; transition: all 0.2s ease;
        }
        .pattern-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .status { margin: 1rem 0; font-size: 1rem; opacity: 0.8; min-height: 40px; }
        .info, .disclaimer {
            margin-top: 2rem; font-size: 0.85rem; opacity: 0.6; line-height: 1.4;
            max-width: 800px; margin-left: auto; margin-right: auto;
        }
        .disclaimer {
              font-style: italic;
              font-size: 0.75rem;
              margin-top: 1rem;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .main-content.editor-visible {
                padding-right: 0;
            }

            .midi-editor-panel {
                width: 100%;
                right: -100%;
                padding: 15px;
            }

            .midi-editor-panel.visible {
                right: 0;
            }

            .title-custom {
                font-size: 2rem;
            }
              .header-logo {
                max-width: 100px;
            }

            .subtitle {
                font-size: 1rem;
            }

            .info, .disclaimer {
                font-size: 0.8rem;
            }

            .instruments-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* --- ESTILOS DO EASTER EGG --- */
        #easter-egg-trigger {
            position: fixed;
            bottom: 0;
            left: 0; /* <-- ALTERADO AQUI */
            width: 50px;
            height: 50px;
            cursor: pointer;
            z-index: 999;
            /* Deixe invisível, mas clicável */
            opacity: 0; 
        }

        #easter-egg-modal {
            display: none; /* Começa escondido */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        #easter-egg-modal.show {
            display: flex; /* Muda para flex para centralizar o conteúdo */
        }

        .modal-content {
            position: relative;
            padding: 20px;
            max-width: 90%;
            max-height: 90%;
        }

        #easter-egg-gif {
            width: 100%;
            height: auto;
            max-width: 80vw; /* 80% da largura da tela */
            max-height: 80vh; /* 80% da altura da tela */
            object-fit: contain; /* Garante que o gif inteiro apareça */
        }
        
        #close-gif-btn {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 2rem;
            color: white;
            background: transparent;
            border: none;
            cursor: pointer;
            text-shadow: 0 0 5px black;
        }
    </style>
</head>
<body>
    <div class="visualizer" id="visualizer"></div>
    <div class="main-content" id="mainContent">
        <div class="container">
            <h1 class="title-custom">Welcome to<img src="./images/soundloop_logo.gif" alt="logo" class="header-logo"></h1>
            <p class="subtitle">Build your own orchestra</p>
            <div class="song-info" id="songInfo">
                <strong>🎼 Current Settings:</strong><br>
                <span id="currentSettings">Press "Play" to start</span>
            </div>
            <div class="main-controls controls">
                <button class="btn" id="playPauseBtn">▶ Play</button>
                <button class="btn" id="stopBtn">⏹ Stop</button>
                <button class="btn" id="recordBtn">🔴 Record</button>
            </div>
            <div class="instruments-grid" id="instrumentsGrid"></div>
            <div class="controls">
                <button class="btn" onclick="window.location.reload()" style="min-width: 200px; margin-top: 1rem;">🔄 New Loop</button>
            </div>
            <div class="status" id="status">Click an instrument to add it to the loop</div>
            <div class="info">
                <strong>How to use:</strong><br>
                1. <strong>New Loop</strong> → Reloads the page with a new random BPM and musical key.<br>
                2. <strong>Play/Pause</strong> → Starts or pauses playback.<br>
                3. <strong>Instruments</strong> → Click to toggle on/off. Loops will start in sync with the music!<br>
                4. <strong>MIDI Editor</strong> → The editor will appear on the side for the selected instrument.
            </div>
            <div class="disclaimer">
                The final product is not made by AI, it is purely a matter of randomness ...and a bit of music theory.
            </div>
        </div>
    </div>

    <div class="midi-editor-panel" id="midiEditorPanel">
        <button id="closeEditorBtn">&times;</button>
        <div id="editor-content" style="display: flex; flex-direction: column; flex-grow: 1;">
            <h3>Select an active instrument to edit its pattern.</h3>
        </div>
    </div>
    
    <div id="easter-egg-trigger"></div>
    <div id="easter-egg-modal">
        <div class="modal-content">
            <button id="close-gif-btn">&times;</button>
            <img id="easter-egg-gif" src="https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExYTdmbHc0ZGo2NnZ6ejJ0eWE1ODI4bW83aXVsMWQxczNicWY5MHd1ZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/bq0yD6VSdcYwqroFaF/giphy.gif" alt="Easter Egg GIF">
        </div>
    </div>


    <script>
        class ProceduralMusicGenerator {
            constructor() {
                this.audioContext = null; this.isPlaying = false;
                this.currentBPM = 120; this.currentKey = 'C'; this.currentScale = 'major';
                this.masterGainNode = null; this.currentlyEditing = null;
                this.instruments = {}; this.midiEditors = {};
                this.isTabActive = true;
                this.isRecording = false;
                this.mediaRecorder = null;
                this.audioChunks = [];
                
                this.globalStep = 0;
                this.masterClockInterval = null;

                this.scales = {
                    major: [0, 2, 4, 5, 7, 9, 11], minor: [0, 2, 3, 5, 7, 8, 10],
                    dorian: [0, 2, 3, 5, 7, 9, 10], pentatonic: [0, 2, 4, 7, 9], blues: [0, 3, 5, 6, 7, 10]
                };
                this.keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                this.instrumentConfigs = {
                    piano:   { name: '🎹 Piano',       synthType: 'triangle', duration: 0.8, isChord: false, color: '#dda0dd', defaultOctave: 4 },
                    synth:   { name: '🎹 Synthesizer',   synthType: 'sawtooth', duration: 1,   isChord: false, color: '#45b7d1', defaultOctave: 4 },
                    guitar:  { name: '🎸 Guitar',       synthType: 'triangle', duration: 0.6, isChord: false, color: '#ff6b6b', defaultOctave: 4 },
                    bass:    { name: '🎯 Bass',         synthType: 'sine',     duration: 0.8, isChord: false, color: '#4ecdc4', defaultOctave: 2 },
                    bass2:   { name: '🎻 Bass 2',       synthType: 'sawtooth', duration: 1.5, isChord: false, color: '#ffa07a', defaultOctave: 2 },
                    choir:   { name: '👥 Choir',         synthType: 'sine',     duration: 2,   isChord: true,  color: '#f4a6d7', defaultOctave: 4 },
                    flute:   { name: '🪈 Flute',       synthType: 'sine',     duration: 1,   isChord: false, color: '#96ceb4', defaultOctave: 5 },
                    drums:   { name: '🥁 Drums',                                                              color: '#ffd700' },
                };

                this.setupUI();
                this.setupEventListeners();
                this.initializeFirstSong();
            }

            setupUI() {
                const grid = document.getElementById('instrumentsGrid');
                Object.keys(this.instrumentConfigs).forEach(key => {
                    const config = this.instrumentConfigs[key];
                    const container = document.createElement('div');
                    container.className = 'instrument-container';
                    container.innerHTML = `
                        <div class="instrument-button-wrapper">
                            <button class="btn instrument-btn" data-instrument="${key}">${config.name}</button>
                            <button class="btn edit-btn" data-instrument="${key}">✏️</button>
                        </div>
                    `;
                    grid.appendChild(container);
                });
            }

            async initAudio() {
                if (!this.audioContext || this.audioContext.state === 'closed') {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGainNode = this.audioContext.createGain();

                    this.mediaStreamDestination = this.audioContext.createMediaStreamDestination();
                    this.masterGainNode.connect(this.audioContext.destination);
                    this.masterGainNode.connect(this.mediaStreamDestination);
                    
                    this.masterGainNode.gain.value = 0.3;
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            initializeFirstSong() {
                this.currentBPM = 80 + Math.floor(Math.random() * 60);
                this.currentKey = this.keys[Math.floor(Math.random() * this.keys.length)];
                this.currentScale = Object.keys(this.scales)[Math.floor(Math.random() * Object.keys(this.scales).length)];
                document.getElementById('currentSettings').innerHTML = `<strong>BPM:</strong> ${this.currentBPM} | <strong>Key:</strong> ${this.currentKey} ${this.currentScale}`;

                for (const instName of Object.keys(this.instrumentConfigs)) {
                    this.midiEditors[instName] = this.generatePatternData(instName);
                }
            }

            openMidiEditor(instrumentName) {
                this.currentlyEditing = instrumentName;
                const panel = document.getElementById('midiEditorPanel');
                const content = document.getElementById('editor-content');
                const defaultConfig = this.instrumentConfigs[instrumentName];

                document.querySelectorAll('.instrument-container').forEach(c => c.classList.remove('editing'));
                document.querySelector(`[data-instrument="${instrumentName}"]`).closest('.instrument-container').classList.add('editing');
                
                content.innerHTML = `
                    <h3>Editing: ${defaultConfig.name}</h3>
                    <div class="midi-controls">
                        <label>Length:</label>
                        <select id="length-${instrumentName}"><option value="32">32</option><option value="64" selected>64</option></select>
                        <label>Volume:</label>
                        <input type="range" id="volume-${instrumentName}" min="0" max="1" step="0.01" value="0.5">
                    </div>
                    <div class="piano-roll-container" id="roll-${instrumentName}"></div>
                    <div class="pattern-controls">
                        <button class="pattern-btn" onclick="musicGen.generateRandomPattern('${instrumentName}', true)">🎲 Random</button>
                        <button class="pattern-btn" onclick="musicGen.clearPattern('${instrumentName}')">🗑️ Clear</button>
                        ${instrumentName !== 'drums' ? `<button class="pattern-btn" onclick="musicGen.createArpeggio('${instrumentName}')">🎵 Arpeggio</button>` : ''}
                    </div>`;
                this.createPianoRoll(instrumentName);
                panel.classList.add('visible');
                document.getElementById('mainContent').classList.add('editor-visible');
                document.getElementById(`length-${instrumentName}`).addEventListener('change', () => this.createPianoRoll(instrumentName));
            }

            closeMidiEditor() {
                if(this.currentlyEditing) {
                    document.querySelector(`[data-instrument="${this.currentlyEditing}"]`).closest('.instrument-container').classList.remove('editing');
                }
                this.currentlyEditing = null;
                document.getElementById('midiEditorPanel').classList.remove('visible');
                document.getElementById('mainContent').classList.remove('editor-visible');
            }

            createPianoRoll(instrumentName) {
                const rollContainer = document.getElementById(`roll-${instrumentName}`);
                if (!rollContainer) return;

                const patternLength = parseInt(document.getElementById(`length-${instrumentName}`)?.value) || 64;
                const isDrums = instrumentName === 'drums';
                
                const notes = isDrums 
                    ? ['Hi-Hat', 'Snare', 'Kick'] 
                    : this.getFullPianoRangeNotes();

                let keysHtml = '<div class="piano-keys">';
                notes.forEach(noteName => {
                    const keyClass = isDrums ? 'drum-key' : (noteName.includes('#') ? 'black-key' : 'white-key');
                    keysHtml += `<div class="note-label ${keyClass}">${noteName}</div>`;
                });
                keysHtml += '</div>';

                let gridHtml = `<div class="note-grid-wrapper"><div class="note-grid" id="grid-${instrumentName}">`;
                for (let beat = 0; beat < patternLength; beat++) {
                    const beatMarkerClass = (beat % 16 === 0) ? ' beat-marker' : '';
                    const drumColumnClass = isDrums ? ' drum-column' : '';
                    gridHtml += `<div class="beat-column${beatMarkerClass}${drumColumnClass}">`;
                    notes.forEach(noteName => {
                        gridHtml += `<div class="note-cell" data-instrument="${instrumentName}" data-note="${noteName}" data-beat="${beat}"></div>`;
                    });
                    gridHtml += `</div>`;
                }
                gridHtml += `</div><div class="playhead" id="playhead-${instrumentName}"></div></div>`;

                rollContainer.innerHTML = keysHtml + gridHtml;


                if (!this.midiEditors[instrumentName] || this.midiEditors[instrumentName].patternLength !== patternLength) {
                     this.midiEditors[instrumentName] = this.generatePatternData(instrumentName, patternLength);
                }
                this.updatePianoRollVisuals(instrumentName);
                
                rollContainer.querySelectorAll('.note-cell').forEach(cell => {
                    cell.addEventListener('click', (e) => {
                        this.toggleNote(instrumentName, e.target.dataset.note, parseInt(e.target.dataset.beat));
                    });
                });
            }

            updatePianoRollVisuals(instrumentName) {
                const patternData = this.midiEditors[instrumentName];
                if(!patternData) return;
                document.querySelectorAll(`[data-instrument="${instrumentName}"].note-cell.active`).forEach(c => c.classList.remove('active'));
                patternData.pattern.forEach((beatData, beat) => {
                    Object.keys(beatData).forEach(note => {
                        if (beatData[note]) {
                            const cell = document.querySelector(`[data-instrument="${instrumentName}"][data-note="${note}"][data-beat="${beat}"]`);
                            if (cell) cell.classList.add('active');
                        }
                    });
                });
            }

            async toggleNote(instrumentName, noteName, beat) {
                await this.initAudio();
                const pattern = this.midiEditors[instrumentName].pattern;
                pattern[beat][noteName] = !pattern[beat][noteName];
                document.querySelector(`[data-instrument="${instrumentName}"][data-note="${noteName}"][data-beat="${beat}"]`).classList.toggle('active');
                if (pattern[beat][noteName] && instrumentName !== 'drums') {
                    this.playNote(this.noteToFrequency(noteName), 0.2, 'sine', 0.2);
                }
            }

            noteToFrequency(noteName) {
                const noteMap = {'C':0, 'C#':1, 'D':2, 'D#':3, 'E':4, 'F':5, 'F#':6, 'G':7, 'G#':8, 'A':9, 'A#':10, 'B':11};
                const octave = parseInt(noteName.match(/\d+/)[0]);
                const note = noteName.replace(/\d+/, '');
                const semitonesFromA4 = (octave - 4) * 12 + noteMap[note] - noteMap['A'];
                return 440 * Math.pow(2, semitonesFromA4 / 12);
            }

            generateRandomPattern(instrumentName, forceRecreate = false) {
                if (!this.midiEditors[instrumentName] || forceRecreate) this.createPianoRoll(instrumentName);
                this.clearPattern(instrumentName);
                const patternData = this.generatePatternData(instrumentName);
                this.midiEditors[instrumentName] = patternData;
                this.updatePianoRollVisuals(instrumentName);
            }

            generatePatternData(instrumentName, patternLength = 64) {
                const pattern = Array.from({ length: patternLength }, () => ({}));
                const config = this.instrumentConfigs[instrumentName];
                const octave = config.defaultOctave || 4;

                if (instrumentName === 'drums') {
                    for (let beat = 0; beat < pattern.length; beat++) {
                        const isLastMeasure = beat >= 48;
                        if (beat % 4 === 0) pattern[beat]['Kick'] = true;
                        
                        if (beat % 8 === 4) {
                            pattern[beat]['Snare'] = true;
                        } else if (isLastMeasure && beat % 2 === 1 && Math.random() < 0.25) { // Fill variation
                            pattern[beat]['Snare'] = true;
                        }

                        if (isLastMeasure && Math.random() < 0.9) {
                            pattern[beat]['Hi-Hat'] = true;
                        } else if (Math.random() < 0.7) {
                            pattern[beat]['Hi-Hat'] = true;
                        }
                    }
                } else {
                    const scaleNotes = this.getHarmonicFieldNotes(octave, instrumentName);
                    for (let beat = 0; beat < pattern.length; beat++) {
                        const isLastMeasure = beat >= 48;
                        let shouldPlaceNote = false;
                        if (config.isChord) {
                            if (beat % 16 === 0 && Math.random() < 0.8) shouldPlaceNote = true;
                        } else {
                            const probability = isLastMeasure ? 0.35 : 0.25;
                            if (Math.random() < probability) shouldPlaceNote = true;
                        }
                        if (shouldPlaceNote) {
                            const randomNote = scaleNotes[Math.floor(Math.random() * scaleNotes.length)];
                            pattern[beat][randomNote] = true;
                        }
                    }
                }
                return { pattern, patternLength };
            }

            getFullPianoRangeNotes(){
                let allNotes = [];
                 for (let oct = 7; oct >= 0; oct--) {
                    const noteOrder = ['B', 'A#', 'A', 'G#', 'G', 'F#', 'F', 'E', 'D#', 'D', 'C#', 'C'];
                    noteOrder.forEach(n => allNotes.push(`${n}${oct}`));
                }
                return allNotes;
            }

            getHarmonicFieldNotes(startOctave, instrumentName) {
                let allNotes = [];
                const isBass = instrumentName === 'bass' || instrumentName === 'bass2';
                const lowerOctaveBound = isBass ? startOctave - 2 : startOctave - 1;
                const upperOctaveBound = isBass ? startOctave : startOctave + 1;

                for (let oct = lowerOctaveBound; oct <= upperOctaveBound; oct++) {
                    if (oct < 1) continue;
                    allNotes.push(...this.getScaleNoteNames(oct));
                }
                const noteOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return allNotes.sort((a, b) => {
                    const octA = parseInt(a.slice(-1)); const octB = parseInt(b.slice(-1));
                    if (octA !== octB) return octB - octA;
                    const noteAIndex = noteOrder.indexOf(a.slice(0, -1).replace(/\d+/,''));
                    const noteBIndex = noteOrder.indexOf(b.slice(0, -1).replace(/\d+/,''));
                    return noteBIndex - noteAIndex;
                });
            }

            getScaleNoteNames(octave) {
                const scaleIntervals = this.scales[this.currentScale];
                const keyOffset = this.keys.indexOf(this.currentKey);
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const notesInScale = [];
                scaleIntervals.forEach(interval => {
                    const noteIndex = (keyOffset + interval) % 12;
                    const currentOctave = octave + Math.floor((keyOffset + interval) / 12);
                    notesInScale.push(`${noteNames[noteIndex]}${currentOctave}`);
                });
                return notesInScale;
            }

            clearPattern(instrumentName) {
                if (!this.midiEditors[instrumentName]) return;
                this.midiEditors[instrumentName].pattern.forEach(b => Object.keys(b).forEach(k => delete b[k]));
                this.updatePianoRollVisuals(instrumentName);
            }

            createArpeggio(instrumentName) {
                this.clearPattern(instrumentName);
                const config = this.instrumentConfigs[instrumentName];
                const scaleNotes = this.getHarmonicFieldNotes(config.defaultOctave, instrumentName).reverse();
                const arpeggioPattern = [...scaleNotes, ...scaleNotes.slice(1, -1).reverse()];
                for (let beat = 0; beat < 16; beat++) {
                    this.toggleNote(instrumentName, arpeggioPattern[beat % arpeggioPattern.length], beat);
                }
            }

            createFireworks(instrumentName) {
                if (!this.isTabActive) return; // Otimização de performance
                const visualizer = document.getElementById('visualizer');
                const config = this.instrumentConfigs[instrumentName];
                if (!config || !config.color || !visualizer) return;

                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                const particleCount = config.isChord ? 30 : 15;

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.backgroundColor = config.color;
                    particle.style.left = `${startX}px`;
                    particle.style.top = `${startY}px`;

                    visualizer.appendChild(particle);

                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 120 + 50;
                    const endX = Math.cos(angle) * distance;
                    const endY = Math.sin(angle) * distance;
                    
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            particle.style.transform = `translate(${endX}px, ${endY}px)`;
                            particle.style.opacity = '0';
                        }, 10);
                    });

                    particle.addEventListener('transitionend', () => {
                        particle.remove();
                    });
                }
            }

            async toggleInstrument(instrumentName) {
                await this.initAudio();
                const button = document.querySelector(`[data-instrument="${instrumentName}"].instrument-btn`);
                const isActivating = !this.instruments[instrumentName];

                if (isActivating) {
                    const nextMeasureStart = Math.ceil(this.globalStep / 16) * 16;
                    this.instruments[instrumentName] = { startStep: nextMeasureStart };
                    button.classList.add('active');
                    if (!this.isPlaying) {
                        this.togglePlayback(true);
                    }
                } else {
                    delete this.instruments[instrumentName];
                    button.classList.remove('active');
                    if (this.currentlyEditing === instrumentName) this.closeMidiEditor();
                }
                this.updateStatus();
            }

            startMasterClock() {
                if (this.masterClockInterval) return;
                const stepDuration = (60 / this.currentBPM) * 1000 / 4; // 16th notes
                this.masterClockInterval = setInterval(() => {
                    if (!this.isPlaying) return;

                    Object.keys(this.instruments).forEach(instrumentName => {
                        const instrument = this.instruments[instrumentName];
                        if (this.globalStep >= instrument.startStep) {
                            const midiEditor = this.midiEditors[instrumentName];
                            if (midiEditor) {
                                const patternLength = midiEditor.patternLength;
                                const localStep = (this.globalStep - instrument.startStep) % patternLength;
                                this.updatePlayhead(instrumentName, localStep, patternLength);
                                this.playMidiNotes(instrumentName, midiEditor.pattern[localStep]);
                            }
                        }
                    });

                    this.globalStep++;
                }, stepDuration);
            }

            stopMasterClock() {
                clearInterval(this.masterClockInterval);
                this.masterClockInterval = null;
            }

            updatePlayhead(instrumentName, localStep, patternLength) {
                const playhead = document.getElementById(`playhead-${instrumentName}`);
                if (playhead) {
                    const grid = document.getElementById(`grid-${instrumentName}`);
                    const totalWidth = grid.scrollWidth;
                    playhead.style.left = `${(localStep / patternLength) * totalWidth}px`;
                }
            }
            
            playMidiNotes(instrumentName, beatData) {
                if (!beatData) return;
                
                const hasNotes = Object.values(beatData).some(v => v);
                if (!hasNotes) return;

                this.createFireworks(instrumentName);

                const config = this.instrumentConfigs[instrumentName];
                const volume = parseFloat(document.getElementById(`volume-${instrumentName}`)?.value) || 0.5;

                if (instrumentName === 'drums') {
                    if (beatData['Kick']) this.createKick(volume);
                    if (beatData['Snare']) this.createSnare(volume);
                    if (beatData['Hi-Hat']) this.createHiHat(volume);
                } else {
                    Object.keys(beatData).forEach(noteName => {
                        if (beatData[noteName]) {
                            const rootFreq = this.noteToFrequency(noteName);
                            
                            if (instrumentName === 'choir') {
                                this.playChoirChord(rootFreq, config, volume);
                            } else if (config.isChord) {
                                this.playStrummedChord(rootFreq, config, volume);
                            } else {
                                this.playNote(rootFreq, config.duration, config.synthType, 0.15 * volume);
                            }
                        }
                    });
                }
            }

            playChoirChord(rootFreq, config, volume) {
                const intervals = this.scales[this.currentScale];
                const thirdInterval = intervals[2];
                const fifthInterval = intervals[4];
                
                this.playNote(rootFreq, config.duration, 'sine', 0.15 * volume, -5);
                this.playNote(rootFreq, config.duration, 'triangle', 0.1 * volume, 5);
                this.playNote(rootFreq * Math.pow(2, fifthInterval / 12), config.duration, 'sine', 0.1 * volume, 0);
            }

            playStrummedChord(rootFreq, config, volume) {
                const intervals = this.scales[this.currentScale];
                const thirdInterval = intervals[2];
                const fifthInterval = intervals[4];
                const seventhInterval = intervals[6];
                
                const strumDelay = 10; // ms

                setTimeout(() => this.playNote(rootFreq, config.duration, config.synthType, 0.15 * volume), 0);
                setTimeout(() => this.playNote(rootFreq * Math.pow(2, thirdInterval / 12), config.duration, config.synthType, 0.1 * volume), strumDelay);
                setTimeout(() => this.playNote(rootFreq * Math.pow(2, fifthInterval / 12), config.duration, config.synthType, 0.1 * volume), strumDelay * 2);
                if (Math.random() < 0.5) {
                    setTimeout(() => this.playNote(rootFreq * Math.pow(2, seventhInterval / 12), config.duration, config.synthType, 0.08 * volume), strumDelay * 3);
                }
            }
            
            async playNote(frequency, duration, type, gainValue, detune = 0) {
                if (!this.audioContext) return;
                const osc = this.audioContext.createOscillator(); const gain = this.audioContext.createGain();
                osc.connect(gain); gain.connect(this.masterGainNode); osc.type = type;
                osc.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                osc.detune.setValueAtTime(detune, this.audioContext.currentTime);
                gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(gainValue, this.audioContext.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                osc.start(this.audioContext.currentTime); osc.stop(this.audioContext.currentTime + duration);
            }

            createKick(volume) {
                const osc = this.audioContext.createOscillator(); const gain = this.audioContext.createGain();
                osc.connect(gain); gain.connect(this.masterGainNode);
                osc.frequency.setValueAtTime(150, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                gain.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start(); osc.stop(this.audioContext.currentTime + 0.5);
            }

            createSnare(volume) {
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0); for (let i = 0; i < this.audioContext.sampleRate; i++) output[i] = Math.random() * 2 - 1;
                noise.buffer = buffer; const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 1000; noise.connect(filter);
                const envelope = this.audioContext.createGain(); filter.connect(envelope); envelope.connect(this.masterGainNode);
                envelope.gain.setValueAtTime(volume * 0.5, this.audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                noise.start(); noise.stop(this.audioContext.currentTime + 0.2);
            }

            createHiHat(volume) {
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0); for (let i = 0; i < this.audioContext.sampleRate; i++) output[i] = Math.random() * 2 - 1;
                noise.buffer = buffer; const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 7000; noise.connect(filter);
                const envelope = this.audioContext.createGain(); filter.connect(envelope); envelope.connect(this.masterGainNode);
                envelope.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                noise.start(); noise.stop(this.audioContext.currentTime + 0.05);
            }

            async togglePlayback(forcePlay = false) {
                await this.initAudio();
                if (forcePlay) {
                    this.isPlaying = true;
                } else {
                    this.isPlaying = !this.isPlaying;
                }

                if(this.isPlaying && !this.masterClockInterval) {
                    this.globalStep = 0;
                    this.startMasterClock();
                } else if (!this.isPlaying) {
                   this.stopMasterClock();
                }
                
                const button = document.getElementById('playPauseBtn');
                button.textContent = this.isPlaying ? '⏸ Pause' : '▶ Play';
                button.classList.toggle('active', this.isPlaying); 
                this.updateStatus();
            }

            async toggleRecording() {
                await this.initAudio();
                const recordBtn = document.getElementById('recordBtn');

                if (this.isRecording) {
                    // Stop
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    recordBtn.textContent = '🔴 Record';
                    recordBtn.classList.remove('recording');
                } else {
                    // Start
                    this.isRecording = true;
                    this.audioChunks = [];
                    this.mediaRecorder = new MediaRecorder(this.mediaStreamDestination.stream);
                    
                    this.mediaRecorder.ondataavailable = event => {
                        this.audioChunks.push(event.data);
                    };

                    this.mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        const reader = new FileReader();
                        reader.onload = async () => {
                            const arrayBuffer = reader.result;
                            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                            const wavBlob = this.bufferToWav(audioBuffer);
                            
                            const a = document.createElement('a');
                            a.style.display = 'none';
                            a.href = URL.createObjectURL(wavBlob);
                            a.download = 'soundloop.wav';
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                        };
                        reader.readAsArrayBuffer(audioBlob);
                    };
                    
                    this.mediaRecorder.start();
                    recordBtn.textContent = '⏹ Stop Recording';
                    recordBtn.classList.add('recording');
                }
            }
            
            bufferToWav(buffer) {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const format = 1; // PCM
                const bitDepth = 16;
                const numSamples = buffer.length;

                const dataSize = numSamples * numChannels * (bitDepth / 8);
                const fileSize = 44 + dataSize;

                const wavBuffer = new ArrayBuffer(fileSize);
                const view = new DataView(wavBuffer);

                let offset = 0;

                // Helper function to write strings
                function writeString(view, offset, string) {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                }

                writeString(view, offset, 'RIFF'); offset += 4;
                view.setUint32(offset, fileSize - 8, true); offset += 4;
                writeString(view, offset, 'WAVE'); offset += 4;
                writeString(view, offset, 'fmt '); offset += 4;
                view.setUint32(offset, 16, true); offset += 4;
                view.setUint16(offset, format, true); offset += 2;
                view.setUint16(offset, numChannels, true); offset += 2;
                view.setUint32(offset, sampleRate, true); offset += 4;
                view.setUint32(offset, sampleRate * numChannels * (bitDepth / 8), true); offset += 4;
                view.setUint16(offset, numChannels * (bitDepth / 8), true); offset += 2;
                view.setUint16(offset, bitDepth, true); offset += 2;
                writeString(view, offset, 'data'); offset += 4;
                view.setUint32(offset, dataSize, true); offset += 4;

                const pcm = new Int16Array(numSamples * numChannels);
                let sampleIndex = 0;
                for (let i = 0; i < numSamples; i++) {
                    for (let channel = 0; channel < numChannels; channel++) {
                        let sample = buffer.getChannelData(channel)[i];
                        sample = Math.max(-1, Math.min(1, sample)); // Clamp
                        pcm[sampleIndex++] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    }
                }

                for (let i = 0; i < pcm.length; i++, offset += 2) {
                    view.setInt16(offset, pcm[i], true);
                }

                return new Blob([view], { type: 'audio/wav' });
            }


            stopAllInstruments(closeEditor = true) {
                this.instruments = {}; this.isPlaying = false;
                this.globalStep = 0;
                this.stopMasterClock();
                document.querySelectorAll('.instrument-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('playPauseBtn').textContent = '▶ Play';
                document.getElementById('playPauseBtn').classList.remove('active');
                if (closeEditor) this.closeMidiEditor();
                this.updateStatus();
            }

            updateStatus() {
                const active = Object.keys(this.instruments);
                const status = this.isPlaying ? 'Playing' : 'Paused';
                if (active.length > 0) {
                    document.getElementById('status').textContent = `${status} | Instruments: ${active.join(', ')}`;
                } else {
                    document.getElementById('status').textContent = 'Select an instrument to add to the composition';
                }
            }

            setupEventListeners() {
                document.getElementById('playPauseBtn').addEventListener('click', () => this.togglePlayback());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopAllInstruments());
                document.getElementById('recordBtn').addEventListener('click', () => this.toggleRecording());
                document.getElementById('closeEditorBtn').addEventListener('click', () => this.closeMidiEditor());
                
                document.querySelectorAll('.instrument-btn').forEach(button => {
                    button.addEventListener('click', () => { this.toggleInstrument(button.dataset.instrument); });
                });
                
                document.querySelectorAll('.edit-btn').forEach(button => {
                    button.addEventListener('click', () => { this.openMidiEditor(button.dataset.instrument); });
                });

                document.addEventListener('visibilitychange', () => {
                    this.isTabActive = !document.hidden;
                });
            }
        }

        let musicGen;
        window.addEventListener('load', () => { 
            musicGen = new ProceduralMusicGenerator(); 

            // --- LÓGICA DO EASTER EGG ---
            const trigger = document.getElementById('easter-egg-trigger');
            const modal = document.getElementById('easter-egg-modal');
            const closeBtn = document.getElementById('close-gif-btn');
            
            // Função para mostrar o modal
            const showModal = () => {
                modal.classList.add('show');
            };

            // Função para esconder o modal
            const hideModal = () => {
                modal.classList.remove('show');
            };

            // Eventos de clique
            trigger.addEventListener('click', showModal);
            closeBtn.addEventListener('click', hideModal);
            
            // Clicar fora do GIF (no fundo escuro) também fecha
            modal.addEventListener('click', (event) => {
                if (event.target === modal) {
                    hideModal();
                }
            });
        });
    </script>
</body>
</html>