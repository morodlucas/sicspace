<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerador de M√∫sica Procedural</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e);
            color: white;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            overflow: hidden; /* Previne scroll geral */
        }

        .visualizer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Atr√°s do conte√∫do principal */
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            transition: transform 1.2s cubic-bezier(0.1, 1, 0.7, 1), opacity 1.2s linear;
        }

        .main-content {
            flex: 1;
            padding-right: 20px;
            transition: padding-right 0.3s ease;
        }

        .main-content.editor-visible {
            padding-right: 440px; /* Espa√ßo para o painel do editor */
        }

        .container {
            text-align: center;
            max-width: 1200px;
            width: 100%;
            margin: 0 auto;
            position: relative;
            z-index: 2;
        }

        .title {
            font-size: 2.8rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 2rem;
            font-style: italic;
        }

        .song-info {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 2rem;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        .main-controls {
            margin-bottom: 2rem;
        }

        .main-controls .btn {
            font-size: 1rem;
            padding: 10px 20px;
            min-width: 120px;
        }

        .instruments-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            max-width: 100%;
            margin: 0 auto 2rem;
        }

        .instrument-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .instrument-container.editing {
            background: rgba(100, 200, 255, 0.15);
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.2);
        }

        .btn {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-family: inherit;
            font-size: 0.95rem;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            width: 100%;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .btn.active {
            background: rgba(100, 200, 255, 0.25);
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.3);
        }

        .midi-editor-panel {
            position: fixed;
            top: 0;
            right: -420px;
            width: 420px;
            height: 100vh;
            background: #101020;
            padding: 20px;
            box-shadow: -10px 0 25px rgba(0, 0, 0, 0.5);
            transition: right 0.3s ease;
            z-index: 100;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        .midi-editor-panel.visible {
            right: 0;
        }
        
        .midi-editor-panel h3 {
            margin-top: 10px;
            color: #a5d8ff;
            flex-shrink: 0;
        }
        
        #closeEditorBtn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        #closeEditorBtn:hover {
            opacity: 1;
        }

        .midi-controls {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-shrink: 0;
        }

        .midi-controls label { font-size: 0.9rem; opacity: 0.8; text-align: right; }
        .midi-controls input, .midi-controls select {
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; padding: 5px 8px; border-radius: 4px; font-family: inherit; font-size: 0.85rem; width: 100%;
        }

        .piano-roll-container {
            display: flex;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            flex-grow: 1;
        }

        .piano-keys {
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .note-label {
            width: 60px;
            height: 20px; 
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.7rem;
            flex-shrink: 0;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .white-key { background: #fff; color: #000; }
        .black-key { background: #333; color: #fff; border-bottom: 1px solid #555; }
        .drum-key { background: rgba(255, 255, 255, 0.05); height: 40px; }

        .note-grid-wrapper {
            flex-grow: 1;
            overflow-x: auto;
            position: relative;
        }
        
        .note-grid {
            display: flex;
            flex-direction: row;
            position: relative;
        }

        .beat-column {
            display: flex;
            flex-direction: column;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        .beat-column.beat-marker {
            border-left: 2px solid rgba(255, 255, 255, 0.3);
        }

        .note-cell {
            width: 35px;
            height: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: background-color 0.1s ease;
            box-sizing: border-box;
        }
        .drum-column .note-cell {
            height: 40px;
        }
        
        .note-cell:hover { background: rgba(255, 255, 255, 0.1); }
        .note-cell.active { background: rgba(100, 200, 255, 0.6); box-shadow: inset 0 0 10px rgba(100, 200, 255, 0.3); }

        .playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: #ff4444;
            z-index: 10;
            transition: left 0.05s linear;
            box-shadow: 0 0 10px #ff4444;
            pointer-events: none;
        }

        .pattern-controls {
            display: flex; gap: 10px; justify-content: center; margin-top: 15px; flex-wrap: wrap; flex-shrink: 0;
        }
        .pattern-btn {
            padding: 6px 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2);
            color: white; cursor: pointer; border-radius: 4px; font-size: 0.8rem; transition: all 0.2s ease;
        }
        .pattern-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .status { margin: 1rem 0; font-size: 1rem; opacity: 0.8; min-height: 40px; }
        .info {
            margin-top: 2rem; font-size: 0.85rem; opacity: 0.6; line-height: 1.4;
            max-width: 800px; margin-left: auto; margin-right: auto;
        }
    </style>
</head>
<body>
    <div class="visualizer" id="visualizer"></div>
    <div class="main-content" id="mainContent">
        <div class="container">
            <h1 class="title">üéµ Gerador de M√∫sica Procedural</h1>
            <p class="subtitle">Crie m√∫sicas √∫nicas com composi√ß√£o algor√≠tmica e edi√ß√£o MIDI</p>
            <div class="song-info" id="songInfo">
                <strong>üéº Configura√ß√£o Atual:</strong><br>
                <span id="currentSettings">Pressione "Gerar Nova M√∫sica" para come√ßar</span>
            </div>
            <div class="main-controls controls">
                <button class="btn" id="generateBtn">üé≤ Gerar Nova M√∫sica</button>
                <button class="btn" id="playPauseBtn">‚ñ∂ Play</button>
                <button class="btn" id="stopBtn">‚èπ Stop</button>
            </div>
            <div class="instruments-grid" id="instrumentsGrid"></div>
            <div class="status" id="status">Clique em "Gerar Nova M√∫sica" para criar uma base musical aleat√≥ria</div>
            <div class="info">
                <strong>Como usar:</strong><br>
                1. <strong>Gerar Nova M√∫sica</strong> ‚Üí Cria BPM e tom aleat√≥rios.<br>
                2. <strong>Play/Pause</strong> ‚Üí Inicia ou pausa a reprodu√ß√£o.<br>
                3. <strong>Instrumentos</strong> ‚Üí Clique para ativar/desativar. Os loops iniciam sincronizados com a m√∫sica!<br>
                4. <strong>Editor MIDI</strong> ‚Üí O editor aparecer√° ao lado para o instrumento selecionado.
            </div>
        </div>
    </div>

    <div class="midi-editor-panel" id="midiEditorPanel">
        <button id="closeEditorBtn">&times;</button>
        <div id="editor-content" style="display: flex; flex-direction: column; flex-grow: 1;">
            <h3>Selecione um instrumento ativo para editar seu padr√£o.</h3>
        </div>
    </div>


    <script>
        class ProceduralMusicGenerator {
            constructor() {
                this.audioContext = null; this.isPlaying = false;
                this.currentBPM = 120; this.currentKey = 'C'; this.currentScale = 'major';
                this.masterGainNode = null; this.currentlyEditing = null;
                this.instruments = {}; this.midiEditors = {};
                
                this.globalStep = 0;
                this.masterClockInterval = null;

                this.scales = {
                    major: [0, 2, 4, 5, 7, 9, 11], minor: [0, 2, 3, 5, 7, 8, 10],
                    dorian: [0, 2, 3, 5, 7, 9, 10], pentatonic: [0, 2, 4, 7, 9], blues: [0, 3, 5, 6, 7, 10]
                };
                this.keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                this.instrumentConfigs = {
                    piano:   { name: 'üéπ Piano',       synthType: 'triangle', duration: 0.8, isChord: false, color: '#dda0dd' },
                    synth:   { name: 'üéπ Sintetizador',  synthType: 'sawtooth', duration: 1,   isChord: false, color: '#45b7d1' },
                    guitar:  { name: 'üé∏ Guitarra',     synthType: 'triangle', duration: 0.6, isChord: false, color: '#ff6b6b' },
                    bass:    { name: 'üéØ Baixo',        synthType: 'sine',     duration: 0.8, isChord: false, color: '#4ecdc4' },
                    strings: { name: 'üéª Cordas',      synthType: 'sawtooth', duration: 1.5, isChord: true,  color: '#ffa07a' },
                    choir:   { name: 'üë• Coro',        synthType: 'sine',     duration: 2,   isChord: true,  color: '#f4a6d7' },
                    flute:   { name: 'ü™à Flauta',      synthType: 'sine',     duration: 1,   isChord: false, color: '#96ceb4' },
                    drums:   { name: 'ü•Å Bateria',                                                            color: '#ffd700' },
                };

                this.setupUI(); this.setupEventListeners(); this.generateNewSong();
            }

            setupUI() {
                const grid = document.getElementById('instrumentsGrid');
                Object.keys(this.instrumentConfigs).forEach(key => {
                    const container = document.createElement('div');
                    container.className = 'instrument-container';
                    container.innerHTML = `<button class="btn instrument" data-instrument="${key}">${this.instrumentConfigs[key].name}</button>`;
                    grid.appendChild(container);
                });
            }

            async initAudio() {
                if (!this.audioContext || this.audioContext.state === 'closed') {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    await this.audioContext.resume();
                    this.masterGainNode = this.audioContext.createGain();
                    this.masterGainNode.connect(this.audioContext.destination);
                    this.masterGainNode.gain.value = 0.3;
                }
            }

            generateNewSong() {
                this.currentBPM = 80 + Math.floor(Math.random() * 60);
                this.currentKey = this.keys[Math.floor(Math.random() * this.keys.length)];
                this.currentScale = Object.keys(this.scales)[Math.floor(Math.random() * Object.keys(this.scales).length)];
                document.getElementById('currentSettings').innerHTML = `<strong>BPM:</strong> ${this.currentBPM} | <strong>Tom:</strong> ${this.currentKey} ${this.currentScale}`;
                
                if (this.masterClockInterval) {
                    this.stopMasterClock();
                    this.startMasterClock();
                }

                Object.keys(this.instruments).forEach(instName => {
                    this.generateRandomPattern(instName, true);
                });
                if(this.currentlyEditing) {
                    this.createPianoRoll(this.currentlyEditing);
                }
                document.getElementById('status').textContent = `Nova m√∫sica gerada! BPM: ${this.currentBPM}, Tom: ${this.currentKey} ${this.currentScale}`;
            }

            openMidiEditor(instrumentName) {
                this.currentlyEditing = instrumentName;
                const panel = document.getElementById('midiEditorPanel');
                const content = document.getElementById('editor-content');
                document.querySelectorAll('.instrument-container').forEach(c => c.classList.remove('editing'));
                document.querySelector(`[data-instrument="${instrumentName}"]`).closest('.instrument-container').classList.add('editing');
                content.innerHTML = `
                    <h3>Editando: ${this.instrumentConfigs[instrumentName].name}</h3>
                    <div class="midi-controls">
                        <label>Dura√ß√£o:</label>
                        <select id="length-${instrumentName}"><option value="16">16</option><option value="32" selected>32</option></select>
                        ${instrumentName !== 'drums' ? `<label>Oitava:</label><select id="octave-${instrumentName}"><option>2</option><option>3</option><option selected>4</option><option>5</option></select>` : ''}
                        <label>Volume:</label>
                        <input type="range" id="volume-${instrumentName}" min="0" max="1" step="0.01" value="0.5">
                    </div>
                    <div class="piano-roll-container" id="roll-${instrumentName}"></div>
                    <div class="pattern-controls">
                        <button class="pattern-btn" onclick="musicGen.generateRandomPattern('${instrumentName}', true)">üé≤ Aleat√≥rio</button>
                        <button class="pattern-btn" onclick="musicGen.clearPattern('${instrumentName}')">üóëÔ∏è Limpar</button>
                        ${instrumentName !== 'drums' ? `<button class="pattern-btn" onclick="musicGen.createArpeggio('${instrumentName}')">üéµ Arpejo</button>` : ''}
                    </div>`;
                this.createPianoRoll(instrumentName);
                panel.classList.add('visible');
                document.getElementById('mainContent').classList.add('editor-visible');
                document.getElementById(`length-${instrumentName}`).addEventListener('change', () => this.createPianoRoll(instrumentName));
                if (document.getElementById(`octave-${instrumentName}`)) {
                    document.getElementById(`octave-${instrumentName}`).addEventListener('change', () => this.createPianoRoll(instrumentName));
                }
            }

            closeMidiEditor() {
                if(this.currentlyEditing) {
                    document.querySelector(`[data-instrument="${this.currentlyEditing}"]`).closest('.instrument-container').classList.remove('editing');
                }
                this.currentlyEditing = null;
                document.getElementById('midiEditorPanel').classList.remove('visible');
                document.getElementById('mainContent').classList.remove('editor-visible');
            }

            createPianoRoll(instrumentName) {
                const rollContainer = document.getElementById(`roll-${instrumentName}`);
                if (!rollContainer) return;

                const patternLength = parseInt(document.getElementById(`length-${instrumentName}`).value);
                const isDrums = instrumentName === 'drums';
                
                const notes = isDrums 
                    ? ['Hi-Hat', 'Snare', 'Kick'] 
                    : this.getHarmonicFieldNotes(parseInt(document.getElementById(`octave-${instrumentName}`).value));

                let keysHtml = '<div class="piano-keys">';
                notes.forEach(noteName => {
                    const keyClass = isDrums ? 'drum-key' : (noteName.includes('#') ? 'black-key' : 'white-key');
                    keysHtml += `<div class="note-label ${keyClass}">${noteName}</div>`;
                });
                keysHtml += '</div>';

                let gridHtml = `<div class="note-grid-wrapper"><div class="note-grid" id="grid-${instrumentName}">`;
                for (let beat = 0; beat < patternLength; beat++) {
                    const beatMarkerClass = (beat % 4 === 0) ? ' beat-marker' : '';
                    const drumColumnClass = isDrums ? ' drum-column' : '';
                    gridHtml += `<div class="beat-column${beatMarkerClass}${drumColumnClass}">`;
                    notes.forEach(noteName => {
                        gridHtml += `<div class="note-cell" data-instrument="${instrumentName}" data-note="${noteName}" data-beat="${beat}"></div>`;
                    });
                    gridHtml += `</div>`;
                }
                gridHtml += `</div><div class="playhead" id="playhead-${instrumentName}"></div></div>`;

                rollContainer.innerHTML = keysHtml + gridHtml;

                if (!this.midiEditors[instrumentName] || this.midiEditors[instrumentName].patternLength !== patternLength) {
                    this.midiEditors[instrumentName] = {
                        pattern: Array.from({ length: patternLength }, () => ({})),
                        patternLength: patternLength
                    };
                }
                this.updatePianoRollVisuals(instrumentName);
                rollContainer.querySelectorAll('.note-cell').forEach(cell => {
                    cell.addEventListener('click', (e) => {
                        this.toggleNote(instrumentName, e.target.dataset.note, parseInt(e.target.dataset.beat));
                    });
                });
            }

            updatePianoRollVisuals(instrumentName) {
                const pattern = this.midiEditors[instrumentName]?.pattern;
                if(!pattern) return;
                document.querySelectorAll(`[data-instrument="${instrumentName}"].note-cell.active`).forEach(c => c.classList.remove('active'));
                pattern.forEach((beatData, beat) => {
                    Object.keys(beatData).forEach(note => {
                        if (beatData[note]) {
                            const cell = document.querySelector(`[data-instrument="${instrumentName}"][data-note="${note}"][data-beat="${beat}"]`);
                            if (cell) cell.classList.add('active');
                        }
                    });
                });
            }

            toggleNote(instrumentName, noteName, beat) {
                const pattern = this.midiEditors[instrumentName].pattern;
                pattern[beat][noteName] = !pattern[beat][noteName];
                document.querySelector(`[data-instrument="${instrumentName}"][data-note="${noteName}"][data-beat="${beat}"]`).classList.toggle('active');
                if (pattern[beat][noteName] && instrumentName !== 'drums') {
                    this.playNote(this.noteToFrequency(noteName), 0.2, 'sine', 0.2);
                }
            }

            noteToFrequency(noteName) {
                const noteMap = {'C':0, 'C#':1, 'D':2, 'D#':3, 'E':4, 'F':5, 'F#':6, 'G':7, 'G#':8, 'A':9, 'A#':10, 'B':11};
                const octave = parseInt(noteName.match(/\d+/)[0]);
                const note = noteName.replace(/\d+/, '');
                const semitonesFromA4 = (octave - 4) * 12 + noteMap[note] - noteMap['A'];
                return 440 * Math.pow(2, semitonesFromA4 / 12);
            }

            generateRandomPattern(instrumentName, forceRecreate = false) {
                if (!this.midiEditors[instrumentName] || forceRecreate) this.createPianoRoll(instrumentName);
                this.clearPattern(instrumentName);
                if (instrumentName === 'drums') {
                    const pattern = this.midiEditors.drums.pattern;
                    for (let beat = 0; beat < pattern.length; beat++) {
                        if (beat % 4 === 0) this.toggleNote('drums', 'Kick', beat);
                        if (beat % 8 === 4) this.toggleNote('drums', 'Snare', beat);
                        if (Math.random() < 0.7) this.toggleNote('drums', 'Hi-Hat', beat);
                    }
                } else {
                    const scaleNotes = this.getHarmonicFieldNotes(parseInt(document.getElementById(`octave-${instrumentName}`).value));
                    const config = this.instrumentConfigs[instrumentName];
                    for (let beat = 0; beat < this.midiEditors[instrumentName].pattern.length; beat++) {
                        let shouldPlaceNote = false;
                        if (config.isChord) {
                            if (beat % 8 === 0 && Math.random() < 0.75) {
                                shouldPlaceNote = true;
                            }
                        } else {
                            if (Math.random() < 0.25) {
                                shouldPlaceNote = true;
                            }
                        }
                        if (shouldPlaceNote) {
                            this.toggleNote(instrumentName, scaleNotes[Math.floor(Math.random() * scaleNotes.length)], beat);
                        }
                    }
                }
                this.updatePianoRollVisuals(instrumentName);
            }

            getHarmonicFieldNotes(startOctave) {
                let allNotes = [];
                for (let oct = startOctave -1; oct <= startOctave + 1; oct++) {
                    allNotes.push(...this.getScaleNoteNames(oct));
                }
                const noteOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                return allNotes.sort((a, b) => {
                    const octA = parseInt(a.slice(-1)); const octB = parseInt(b.slice(-1));
                    if (octA !== octB) return octB - octA;
                    const noteAIndex = noteOrder.indexOf(a.slice(0, -1).replace(/\d+/,''));
                    const noteBIndex = noteOrder.indexOf(b.slice(0, -1).replace(/\d+/,''));
                    return noteBIndex - noteAIndex;
                });
            }

            getScaleNoteNames(octave) {
                const scaleIntervals = this.scales[this.currentScale];
                const keyOffset = this.keys.indexOf(this.currentKey);
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const notesInScale = [];
                scaleIntervals.forEach(interval => {
                    const noteIndex = (keyOffset + interval) % 12;
                    const currentOctave = octave + Math.floor((keyOffset + interval) / 12);
                    notesInScale.push(`${noteNames[noteIndex]}${currentOctave}`);
                });
                return notesInScale;
            }

            clearPattern(instrumentName) {
                if (!this.midiEditors[instrumentName]) return;
                this.midiEditors[instrumentName].pattern.forEach(b => Object.keys(b).forEach(k => delete b[k]));
                this.updatePianoRollVisuals(instrumentName);
            }

            createArpeggio(instrumentName) {
                this.clearPattern(instrumentName);
                const scaleNotes = this.getHarmonicFieldNotes(parseInt(document.getElementById(`octave-${instrumentName}`).value)).reverse();
                for (let beat = 0; beat < 16; beat++) {
                    this.toggleNote(instrumentName, scaleNotes[beat % scaleNotes.length], beat);
                }
            }

            createFireworks(instrumentName) {
                const visualizer = document.getElementById('visualizer');
                const config = this.instrumentConfigs[instrumentName];
                if (!config || !config.color || !visualizer) return;

                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                const particleCount = config.isChord ? 30 : 15;

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.backgroundColor = config.color;
                    particle.style.left = `${startX}px`;
                    particle.style.top = `${startY}px`;

                    visualizer.appendChild(particle);

                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 120 + 50;
                    const endX = Math.cos(angle) * distance;
                    const endY = Math.sin(angle) * distance;
                    
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            particle.style.transform = `translate(${endX}px, ${endY}px)`;
                            particle.style.opacity = '0';
                        }, 10);
                    });

                    particle.addEventListener('transitionend', () => {
                        particle.remove();
                    });
                }
            }

            async toggleInstrument(instrumentName) {
                await this.initAudio();
                const button = document.querySelector(`[data-instrument="${instrumentName}"]`);
                const isActivating = !this.instruments[instrumentName];

                if (isActivating) {
                    const nextMeasureStart = Math.ceil(this.globalStep / 16) * 16;
                    this.instruments[instrumentName] = { startStep: nextMeasureStart };
                    button.classList.add('active');
                    this.openMidiEditor(instrumentName);
                    if (!this.midiEditors[instrumentName]?.pattern.some(b => Object.keys(b).length > 0)) {
                        this.generateRandomPattern(instrumentName);
                    }
                } else {
                    delete this.instruments[instrumentName];
                    button.classList.remove('active');
                    if (this.currentlyEditing === instrumentName) this.closeMidiEditor();
                }
                this.updateStatus();
            }

            startMasterClock() {
                if (this.masterClockInterval) return;
                const stepDuration = (60 / this.currentBPM) * 1000 / 4; // 16th notes
                this.masterClockInterval = setInterval(() => {
                    if (!this.isPlaying) return;

                    Object.keys(this.instruments).forEach(instrumentName => {
                        const instrument = this.instruments[instrumentName];
                        if (this.globalStep >= instrument.startStep) {
                            const midiEditor = this.midiEditors[instrumentName];
                            if (midiEditor) {
                                const patternLength = midiEditor.patternLength;
                                const localStep = (this.globalStep - instrument.startStep) % patternLength;
                                this.updatePlayhead(instrumentName, localStep, patternLength);
                                this.playMidiNotes(instrumentName, midiEditor.pattern[localStep]);
                            }
                        }
                    });

                    this.globalStep++;
                }, stepDuration);
            }

            stopMasterClock() {
                clearInterval(this.masterClockInterval);
                this.masterClockInterval = null;
            }

            updatePlayhead(instrumentName, localStep, patternLength) {
                const playhead = document.getElementById(`playhead-${instrumentName}`);
                if (playhead) {
                    const grid = document.getElementById(`grid-${instrumentName}`);
                    const totalWidth = grid.scrollWidth;
                    playhead.style.left = `${(localStep / patternLength) * totalWidth}px`;
                }
            }
            
            playMidiNotes(instrumentName, beatData) {
                if (!beatData) return;
                
                const hasNotes = Object.values(beatData).some(v => v);
                if (!hasNotes) return;

                this.createFireworks(instrumentName);

                const config = this.instrumentConfigs[instrumentName];
                const volume = parseFloat(document.getElementById(`volume-${instrumentName}`)?.value) || 0.5;

                if (instrumentName === 'drums') {
                    if (beatData['Kick']) this.createKick(volume);
                    if (beatData['Snare']) this.createSnare(volume);
                    if (beatData['Hi-Hat']) this.createHiHat(volume);
                } else {
                    Object.keys(beatData).forEach(noteName => {
                        if (beatData[noteName]) {
                            const rootFreq = this.noteToFrequency(noteName);
                            this.playNote(rootFreq, config.duration, config.synthType, 0.15 * volume);
                            if (config.isChord) {
                                const thirdInterval = this.currentScale.includes('minor') ? 3 : 4;
                                const thirdFreq = rootFreq * Math.pow(2, thirdInterval / 12);
                                const fifthFreq = rootFreq * Math.pow(2, 7 / 12);
                                this.playNote(thirdFreq, config.duration, config.synthType, 0.1 * volume);
                                this.playNote(fifthFreq, config.duration, config.synthType, 0.1 * volume);
                            }
                        }
                    });
                }
            }
            
            async playNote(frequency, duration, type, gainValue) {
                if (!this.audioContext) return;
                const osc = this.audioContext.createOscillator(); const gain = this.audioContext.createGain();
                osc.connect(gain); gain.connect(this.masterGainNode); osc.type = type;
                osc.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                gain.gain.setValueAtTime(0, this.audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(gainValue, this.audioContext.currentTime + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                osc.start(this.audioContext.currentTime); osc.stop(this.audioContext.currentTime + duration);
            }

            createKick(volume) {
                const osc = this.audioContext.createOscillator(); const gain = this.audioContext.createGain();
                osc.connect(gain); gain.connect(this.masterGainNode);
                osc.frequency.setValueAtTime(150, this.audioContext.currentTime);
                osc.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                gain.gain.setValueAtTime(volume, this.audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
                osc.start(); osc.stop(this.audioContext.currentTime + 0.5);
            }

            createSnare(volume) {
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0); for (let i = 0; i < this.audioContext.sampleRate; i++) output[i] = Math.random() * 2 - 1;
                noise.buffer = buffer; const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 1000; noise.connect(filter);
                const envelope = this.audioContext.createGain(); filter.connect(envelope); envelope.connect(this.masterGainNode);
                envelope.gain.setValueAtTime(volume * 0.5, this.audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                noise.start(); noise.stop(this.audioContext.currentTime + 0.2);
            }

            createHiHat(volume) {
                const noise = this.audioContext.createBufferSource();
                const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0); for (let i = 0; i < this.audioContext.sampleRate; i++) output[i] = Math.random() * 2 - 1;
                noise.buffer = buffer; const filter = this.audioContext.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 7000; noise.connect(filter);
                const envelope = this.audioContext.createGain(); filter.connect(envelope); envelope.connect(this.masterGainNode);
                envelope.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime);
                envelope.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);
                noise.start(); noise.stop(this.audioContext.currentTime + 0.05);
            }

            togglePlayback() {
                this.isPlaying = !this.isPlaying;
                if(this.isPlaying && !this.masterClockInterval) {
                    this.globalStep = 0;
                    this.startMasterClock();
                }
                const button = document.getElementById('playPauseBtn');
                button.textContent = this.isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
                button.classList.toggle('active', this.isPlaying); this.updateStatus();
            }

            stopAllInstruments() {
                this.instruments = {}; this.isPlaying = false;
                this.globalStep = 0;
                this.stopMasterClock();
                document.querySelectorAll('.instrument').forEach(b => b.classList.remove('active'));
                document.getElementById('playPauseBtn').textContent = '‚ñ∂ Play';
                document.getElementById('playPauseBtn').classList.remove('active');
                this.closeMidiEditor(); this.updateStatus();
            }

            updateStatus() {
                const active = Object.keys(this.instruments);
                const status = this.isPlaying ? 'Tocando' : 'Pausado';
                if (active.length > 0) {
                    document.getElementById('status').textContent = `${status} | Instrumentos: ${active.join(', ')}`;
                } else {
                    document.getElementById('status').textContent = 'Selecione instrumentos para adicionar √† composi√ß√£o';
                }
            }

            setupEventListeners() {
                document.getElementById('generateBtn').addEventListener('click', () => this.generateNewSong());
                document.getElementById('playPauseBtn').addEventListener('click', () => this.togglePlayback());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopAllInstruments());
                document.getElementById('closeEditorBtn').addEventListener('click', () => this.closeMidiEditor());
                document.querySelectorAll('.instrument').forEach(button => {
                    button.addEventListener('click', () => { this.toggleInstrument(button.dataset.instrument); });
                });
            }
        }

        let musicGen;
        window.addEventListener('load', () => { musicGen = new ProceduralMusicGenerator(); });
    </script>
</body>
</html>

